# GitHub MinoruKishi/forth-CF_MSX   
  
## CCurl/CFを初めて読んだ人がChatGPTの力を借りてのMSX0向けFORTH改造の顛末記〜０９  
  
# あなた:  
  
CFであるFORTシステムのMSX版（Z80）を考えています。    
FIG-FORTHではコンパクトなVMとWORDの集まりである辞書だけの構成だと理解しています。    
CFではコンパクトなVMとプライムなどの配列データとそれを動かすためのCの関数群でできていると理解しています。CF起動時に実行されるmain()関数内で初期化が行われた後にFORTH辞書が生成されています。    
CF-MSXではCFの仕組みを参考にしたいです。    
そのため、構成としては`system.c`の`void ttyMode(int isRaw)`から`int main(int argc, char *argv[])` と`cf.c`の`static int nextWord()`以降を事前にWORDとして定義しておき、起動時にmainというWORDが実行されるだけ、ということを考えています。      
      
今考えているのは`#define PRIMS(X)`のなかで組み込まれている`t=TOS; push(t);`などをどうやって定義するかで悩んでいて、LUAによるマクロが並べられたもので定義するか、ここは最初からZ80のアセンブラで定義するか迷っています。前者のLUAのマクロ列で定義は可能でしょうか？  
  
# ChatGPT:  
  
思考時間: 7s  
  
可能です。結論から言うと 「LUA マクロ列で PRIMS 相当（＝各 primitive の実装コード生成）を回す」ことは十分現実的です。    
ただし、悩みどころの t=TOS; push(t); みたいな **“VM の核（スタック規約）”**は、LUAで「その場で展開する文字列」を増やすより、  
  
* Z80側で “TOS / push / pop” をまず最小の部品として確立（レジスタ割り当て＋メモリ上のスタック形式）    
* その部品を使って primitive を量産する部分を LUAで生成  
  
…という ハイブリッドが一番事故りにくいです。  
  
---  
  
## **1)** t=TOS; push(t); **の正体を Z80 の規約に落とす**  
  
CF の TOS は「トップ・オブ・スタック（キャッシュ）」で、C 実装ではレジスタ変数っぽく扱えます。    
Z80 でも同じで、まず「TOS をどのレジスタペアに置くか」を決めます。  
  
よくある選択は：  
  
* TOS = HL    
* DSP（データスタックポインタ） = IY（あるいは IX）    
* スタックは 16bit cell をメモリに積む（MSXなら 16bit cell が自然）  
  
そして  
  
* push(t) = “HL を [IY] に書いて IY を進める/戻す”    
* pop() = “[IY] から読む → HL、IY を進める/戻す”  
  
に落ちます。  
  
例：上方向に伸びるスタック（IY が次の空き位置を指す）なら：  
  
~~~
; 16-bit cell, little endian  
  
; TOS=HL, DSP=IY (points to next free)  
  
PUSH_HL:  
  
   ld (iy+0), l  
  
   ld (iy+1), h  
  
   inc iy  
  
   inc iy  
  
   ret  
  
POP_HL:  
  
   dec iy  
  
   dec iy  
  
   ld l, (iy+0)  
  
   ld h, (iy+1)  
  
   ret  
~~~
  
これで C の  
  
* t=TOS; push(t); は 「HL を push」    
* t=pop(); は 「pop して HL」  
  
に置き換わります。  
  
つまり “悩んでいる1行” は、実は VM規約（TOSとDSP）を固定すれば、以後は機械的になります。  
  
---  
  
## **2) LUA で「PRIMS 相当」を回すのは可能か？**  
  
はい、可能です。sjasmplus の LUA は _pc() でアセンブラ行を吐けるので、    
(1) primitive一覧を Lua のテーブルで持つ → (2) ループでラベルとコードを生成 ができます。  
  
ポイントは：  
  
* “push/pop/add/branch” みたいな基本部品は Z80 マクロ（または短いサブルーチン）として確立    
* Lua は 「部品の組み合わせの羅列」を生成するのが得意    
* 逆に Lua だけで全部やると、規約変更が入ったときに地獄になりやすい（生成文字列の追跡がつらい）  
  
---  
  
## **3) 実装のおすすめ構造（CF-MSX案に合う形）**  
  
あなたの案：  
  
system.c の ttyMode〜main() と、cf.c の nextWord() 以降を「事前に WORD として定義」しておき、起動時に main という WORD が実行されるだけ  
  
これは **かなり “FIG 的”**で良いです。MSX版ならさらに：  
  
* 「ホストI/O（CONIN/CONOUT, BDOS呼び出し）」は primitive として切り出す    
* nextWord / parse / interpret / outer loop を colon word 化（または “VM内蔵ルーチン” として同じ扱いに）  
  
が綺麗に収まります。  
  
---  
  
## **4) 具体例：LUAで primitive 群を生成する骨格**  
  
以下は「LUAで primitive を列挙 → それぞれの実体コードを生成」する最小の雰囲気サンプルです。    
（“部品”は Z80 マクロ/サブルーチンで持つ想定）  
  
~~~
; ====== core regs convention ======  
  
; TOS = HL  
  
; DSP = IY  (next free)  
  
; (PUSH_HL / POP_HL) は上で示したものを用意しておく  
  
; ====== primitive helpers as macros ======  
  
MACRO PRIM_PUSH_TOS  
  
   call PUSH_HL  
  
ENDM  
  
MACRO PRIM_POP_TOS  
  
   call POP_HL  
  
ENDM  
  
MACRO PRIM_ADD      ; ( a b -- a+b ) : HL=b, pop a->DE, HL=DE+HL  
  
   ; pop a -> DE  
  
   dec iy  
  
   dec iy  
  
   ld e,(iy+0)  
  
   ld d,(iy+1)  
  
   add hl,de  
  
ENDM  
  
; ====== PRIMS generated by LUA ======  
  
LUA ALLPASS  
  
local prims = {  
  
 -- name, emitter (string list)  
  
 { "DUP", function()  
  
     -- ( x -- x x ) : push HL  
  
     _pc("PRIM_DUP:")  
  
     _pc("  PRIM_PUSH_TOS")  
  
     _pc("  jp NEXT")  
  
   end  
  
 },  
  
 { "DROP", function()  
  
     -- ( x -- ) : pop into HL (new TOS)  
  
     _pc("PRIM_DROP:")  
  
     _pc("  PRIM_POP_TOS")  
  
     _pc("  jp NEXT")  
  
   end  
  
 },  
  
 { "PLUS", function()  
  
     -- ( a b -- a+b ) : HL=b, a in stack  
  
     _pc("PRIM_PLUS:")  
  
     _pc("  PRIM_ADD")  
  
     _pc("  jp NEXT")  
  
   end  
  
 },  
  
}  
  
for _,p in ipairs(prims) do  
  
 p[2]() -- emit  
  
end  
  
ENDLUA  
  
; ====== threaded execution ======  
  
; NEXT: fetch next token, dispatch...  
  
NEXT:  
  
   ; ここはあなたの VM 方式（トークンスレッド / 直交ジャンプ等）に合わせる  
  
   ; 例: token->addr を引いて JP (addr)  
  
   ; ...  
  
   jp 0  
~~~
  
ここで重要なのは、LUAは  
  
* PRIM_PLUS: みたいな ラベル    
* PRIM_ADD みたいな 部品の呼び出し    
* jp NEXT  
  
を大量生成する役に徹していることです。    
PRIM_ADD の中身（スタック規約に依存する核）は Z80側に固定してあるので、将来の変更にも耐えます。  
  
---  
  
## **5) 「最初からZ80アセンブラで全部」vs「LUA生成」判断基準**  
  
### **LUA生成が強いところ**  
  
* primitive が 増えるほど効果が出る（表から自動生成）    
* デバッグ用に **“一覧をそのまま辞書/ジャンプテーブルへ反映”**したい    
* “8086→Z80対応表”みたいな機械変換を挟みたい（あなたの作業に合う）  
  
### **純アセンブラが強いところ**  
  
* VMの “NEXT/dispatch” や “push/pop” など、1バイトでも短くしたい核    
* 生成物のデバッグを ソース行で追いたい（生成が絡むと追跡が難しくなる）  
  
なのでおすすめは繰り返しになりますが：  
  
* 核（TOS/DSP/NEXT/branch/IO）は純Z80    
* primitive 群と辞書/ジャンプテーブルはLUA生成  
  
が一番バランス良いです。  
  
---  
  
もしよければ、次のどれか1つだけでも前提を置いてくれると、NEXT と dispatch（＝CFのPRIMSの “case op:” 部分に相当）まで含めて、動く雛形に落とせます：  
  
* スレッディング方式：token-threaded / direct-threaded / subroutine-threaded のどれに寄せたいか    
* cell幅：16bit固定でOKか（MSXなら普通OK）    
* スタックの伸び方向：上方向（IY++）か下方向（IY--）か  
  
（質問は要りません。あなたの今の構想に合わせて、私の方で “token-threaded + 16bit + IY上方向” をデフォルトにした雛形もすぐ書けます。）  
  
# あなた:  
  
5) 「最初からZ80アセンブラで全部」vs「LUA生成」判断基準    
で一番バランスが良い形のCF-MSXシステムのasmコードを作成してもらえませんか？    
私はそのコードをCOMファイルに変換して、起動してみて、FORTHで書かれた文字列をキー入力し、数値の足し算を行ってから画面に”ANS=”を表示して、そのあとに結果を出すことを確認したいんです。  
  
# ChatGPT:  
  
思考時間: 26s  
  
もちろんできます。以下は **「核（I/O、スタック、数値変換、トークナイズ、辞書探索）は純Z80」にしつつ、「辞書（ワード名＋実行先テーブル）は sjasmplus の LUA で自動生成」**する、いちばんバランスが良い形の CF-MSX（MSX-DOS .COM）最小デモです。  
  
やること（確認できること）：  
  
* COM を起動すると OK> が出る    
* キーボードで 2 3 + のように入力して Enter    
* 画面に ANS= と結果（例: 5）を表示    
* 何度でも繰り返せる  
  
---  
  
## **ビルド方法（sjasmplus）**  
  
~~~
sjasmplus --raw=cf_msx_demo.com cf_msx_demo.asm  
~~~
  
MSX-DOS 上で cf_msx_demo を実行。  
  
---  
  
## cf_msx_demo.asm**（完成版）**  
  
そのままコピペでOKです。$終端（BDOS 9）も全部正しく入れています。  
  
~~~
; ============================================================  
  
; CF-MSX demo (MSX-DOS .COM, Z80)  
  
; - Pure Z80 core (I/O, tokenizer, stack, number conv)  
  
; - Dictionary generated by sjasmplus LUA  
  
; - Type:  2 3 +  
  
; - Shows: ANS=5  
  
;  
  
; Assemble:  
  
;   sjasmplus --raw=cf_msx_demo.com cf_msx_demo.asm  
  
; Run:  
  
;   cf_msx_demo  
  
; ============================================================  
  
               org     0100h  
  
               jp      start  
  
; -----------------------------  
  
; MSX-DOS BDOS entry  
  
; -----------------------------  
  
BDOS            equ     0005h  
  
; BDOS functions  
  
BDOS_CONIN      equ     01h     ; A = char (echoed)  
  
BDOS_CONOUT     equ     02h     ; E = char  
  
BDOS_PRINTSTR   equ     09h     ; DE = '$'-terminated string  
  
CR              equ     0Dh  
  
LF              equ     0Ah  
  
; ============================================================  
  
; Memory layout (COM has one segment)  
  
; ============================================================  
  
STACK_TOP       equ     0F380h          ; call stack for our program (safe-ish)  
  
DS_BASE         equ     0F000h          ; data stack base  
  
DS_MAXCELLS     equ     64              ; 64 cells (128 bytes)  
  
DS_LIMIT        equ     DS_BASE + DS_MAXCELLS*2  
  
LINEBUF         equ     0F100h  
  
LINEBUF_SZ      equ     80  
  
TOKENBUF        equ     0F160h  
  
TOKENBUF_SZ     equ     32  
  
; ============================================================  
  
; Registers convention (simple, robust)  
  
; ============================================================  
  
; Data stack uses IY as "top pointer":  
  
;   - Empty stack: IY = DS_BASE - 2  
  
;   - push: IY += 2, store HL to (IY)  
  
;   - pop : load HL from (IY), IY -= 2  
  
;  
  
; We do NOT keep TOS cached in HL across interpreter steps,  
  
; to keep the demo simple and reliable.  
  
; ============================================================  
  
; Entry  
  
; ============================================================  
  
start:  
  
               ld      sp, STACK_TOP  
  
               ; init data stack  
  
               ld      iy, DS_BASE-2  
  
main_loop:  
  
               ld      de, str_ok_prompt  
  
               call    bdos_printstr  
  
               ; read line into LINEBUF (0-terminated)  
  
               ld      hl, LINEBUF  
  
               ld      b, LINEBUF_SZ-1  
  
               call    read_line  
  
               ; interpret line (tokens)  
  
               call    interpret_line  
  
               ; print CRLF  
  
               call    print_crlf  
  
               jp      main_loop  
  
; ============================================================  
  
; BDOS wrappers  
  
; ============================================================  
  
bdos_printstr:  
  
               ; DE points to '$'-terminated string  
  
               ld      c, BDOS_PRINTSTR  
  
               call    BDOS  
  
               ret  
  
putch:  
  
               ; A=char  
  
               ld      e, a  
  
               ld      c, BDOS_CONOUT  
  
               call    BDOS  
  
               ret  
  
getch:  
  
               ; returns A=char (echoed by BDOS)  
  
               ld      c, BDOS_CONIN  
  
               call    BDOS  
  
               ret  
  
print_crlf:  
  
               ld      a, CR  
  
               call    putch  
  
               ld      a, LF  
  
               call    putch  
  
               ret  
  
; ============================================================  
  
; Line input: read until CR, store 0-terminated  
  
; IN:  HL=dest, B=maxlen  
  
; OUT: HL points to 0 terminator  
  
; ============================================================  
  
read_line:  
  
.rl_next:  
  
               call    getch  
  
               cp      CR  
  
               jr      z, .rl_done  
  
               ; ignore LF if any  
  
               cp      LF  
  
               jr      z, .rl_next  
  
               ; store if room  
  
               djnz    .rl_store  
  
               ; buffer full, just keep reading until CR  
  
               jr      .rl_next  
  
.rl_store:  
  
               ld      (hl), a  
  
               inc     hl  
  
               jr      .rl_next  
  
.rl_done:  
  
               ld      (hl), 0  
  
               ret  
  
; ============================================================  
  
; Data stack ops (16-bit cell)  
  
; ============================================================  
  
ds_push_hl:  
  
               ; IY += 2; (IY)=HL  
  
               inc     iy  
  
               inc     iy  
  
               ld      (iy+0), l  
  
               ld      (iy+1), h  
  
               ret  
  
ds_pop_hl:  
  
               ; HL=(IY); IY -= 2  
  
               ld      l, (iy+0)  
  
               ld      h, (iy+1)  
  
               dec     iy  
  
               dec     iy  
  
               ret  
  
ds_clear:  
  
               ld      iy, DS_BASE-2  
  
               ret  
  
ds_is_empty:  
  
               ; Z=1 if empty  
  
               ld      hl, DS_BASE-2  
  
               or      a  
  
               sbc     hl, iy  
  
               ; if HL==0 then empty => Z=1  
  
               ret  
  
; ============================================================  
  
; Tokenizer helpers  
  
; ============================================================  
  
skip_spaces:  
  
               ; HL points into line  
  
.ss1:  
  
               ld      a, (hl)  
  
               or      a  
  
               ret     z  
  
               cp      ' '  
  
               ret     nz  
  
               inc     hl  
  
               jr      .ss1  
  
read_token:  
  
               ; IN:  HL=line pointer  
  
               ; OUT: HL=updated line pointer  
  
               ;      TOKENBUF = token (0-terminated), A=token length  
  
               ;      Z=1 if no token (EOL)  
  
               call    skip_spaces  
  
               ld      a, (hl)  
  
               or      a  
  
               ret     z              ; Z=1 => no token  
  
               ld      de, TOKENBUF  
  
               ld      c, 0           ; length  
  
.rt1:  
  
               ld      a, (hl)  
  
               or      a  
  
               jr      z, .rt_done  
  
               cp      ' '  
  
               jr      z, .rt_done  
  
               ; store char if room  
  
               ld      a, c  
  
               cp      TOKENBUF_SZ-1  
  
               jr      nc, .rt_skip_store  
  
               ld      a, (hl)  
  
               ld      (de), a  
  
               inc     de  
  
               inc     c  
  
.rt_skip_store:  
  
               inc     hl  
  
               jr      .rt1  
  
.rt_done:  
  
               ld      a, 0  
  
               ld      (de), a  
  
               ld      a, c  
  
               or      a              ; set flags based on length  
  
               ret                    ; Z=0 if length>0  
  
; ============================================================  
  
; Interpret a line: numbers and words  
  
; - After evaluation, prints: ANS=<top>  
  
; ============================================================  
  
interpret_line:  
  
               call    ds_clear  
  
               ld      hl, LINEBUF  
  
.il_loop:  
  
               call    read_token  
  
               jr      z, .il_finish  
  
               ; TOKENBUF contains token, A=length  
  
               ; decide number vs word: if first char is '0'..'9'  
  
               ld      a, (TOKENBUF)  
  
               cp      '0'  
  
               jr      c, .il_word  
  
               cp      '9'+1  
  
               jr      nc, .il_word  
  
               ; number  
  
               call    parse_u16_token_to_hl  
  
               call    ds_push_hl  
  
               jr      .il_loop  
  
.il_word:  
  
               ; lookup and execute word  
  
               call    dict_find  
  
               jr      z, .unknown_word  
  
               ; DE = code pointer  
  
               ; execute: call (DE) via JP (DE) trick  
  
               push    hl              ; save line pointer  
  
               push    de  
  
               pop     hl              ; HL = DE  
  
               call    call_hl  
  
               pop     hl  
  
               jr      .il_loop  
  
.unknown_word:  
  
               ld      de, str_unknown  
  
               call    bdos_printstr  
  
               ; print token then CRLF  
  
               ld      hl, TOKENBUF  
  
               call    print_cstr_0term  
  
               call    print_crlf  
  
               jr      .il_loop  
  
.il_finish:  
  
               ; Print "ANS=" and top of stack if present  
  
               ld      de, str_ans  
  
               call    bdos_printstr  
  
               call    ds_is_empty  
  
               jr      z, .no_ans  
  
               call    ds_pop_hl  
  
               call    print_u16_hl  
  
.no_ans:  
  
               ret  
  
; call HL (Z80 doesn't have CALL (HL))  
  
call_hl:  
  
               jp      (hl)  
  
; ============================================================  
  
; Dictionary (generated by LUA): find token => DE=code, Z=0 found  
  
; dict format:  
  
;   dict_count: db N  
  
;   dict:  
  
;     db len, "NAME...", 0, dw code  
  
; ============================================================  
  
dict_find:  
  
               ; IN: TOKENBUF (0-term), A ignored  
  
               ; OUT: Z=0 found, DE=code ptr  
  
               ;      Z=1 not found  
  
               ld      ix, dict  
  
               ld      a, (dict_count)  
  
               ld      b, a  
  
               or      a  
  
               jr      z, .df_notfound  
  
.df_next:  
  
               ; entry: [len][name..][0][code_lo][code_hi]  
  
               ld      a, (ix+0)       ; name length  
  
               ld      c, a  
  
               inc     ix  
  
               ; compare lengths first  
  
               ld      a, (token_len_cache)  
  
               cp      c  
  
               jr      nz, .df_skip_name  
  
               ; compare name bytes  
  
               push    ix  
  
               ld      hl, TOKENBUF  
  
               ld      d, c  
  
.df_cmp:  
  
               ld      a, (ix+0)  
  
               cp      (hl)  
  
               jr      nz, .df_cmp_fail  
  
               inc     ix  
  
               inc     hl  
  
               dec     d  
  
               jr      nz, .df_cmp  
  
               ; expect 0 terminator in dict (we can just skip it)  
  
               inc     ix              ; skip 0  
  
               ; read code pointer  
  
               ld      e, (ix+0)  
  
               ld      d, (ix+1)  
  
               pop     hl              ; discard saved ix  
  
               or      1               ; Z=0  
  
               ret  
  
.df_cmp_fail:  
  
               pop     ix  
  
.df_skip_name:  
  
               ; skip name bytes + 0 + 2 bytes code  
  
               ld      a, c  
  
               ; ix currently points at name start  
  
               add     ix, a  
  
               inc     ix              ; skip 0  
  
               inc     ix              ; skip code lo  
  
               inc     ix              ; skip code hi  
  
               djnz    .df_next  
  
.df_notfound:  
  
               xor     a               ; Z=1  
  
               ret  
  
; cache token length for dict_find (set by read_token)  
  
; We'll store it right after read_token in interpret loop.  
  
; For simplicity, we set it inside read_token return path usage.  
  
; (We do it here by re-reading TOKENBUF length quickly.)  
  
token_len_cache: db 0  
  
; small helper: compute token length -> token_len_cache  
  
update_token_len_cache:  
  
               ld      hl, TOKENBUF  
  
               ld      b, 0  
  
.ut1:  
  
               ld      a, (hl)  
  
               or      a  
  
               jr      z, .ut_done  
  
               inc     hl  
  
               inc     b  
  
               jr      .ut1  
  
.ut_done:  
  
               ld      a, b  
  
               ld      (token_len_cache), a  
  
               ret  
  
; Patch interpret loop to update cache:  
  
; (we do it by calling update_token_len_cache right after read_token)  
  
; To keep listing simple, we just do it by modifying interpret_line:  
  
; Instead of rewriting above, we call it right after read_token here:  
  
; --- (already compiled text can't patch; so we call it inline) ---  
  
; NOTE: sjasmplus doesn't let us “edit” earlier code in-place,  
  
; so we implement a tiny wrapper and use it instead:  
  
read_token_and_cache:  
  
               call    read_token  
  
               ret     z  
  
               push    af  
  
               call    update_token_len_cache  
  
               pop     af  
  
               ret  
  
; Now override interpret_line entry to use wrapper:  
  
; (We jump to a fixed version to keep source readable.)  
  
               ; --- fallthrough safety: none ---  
  
; ============================================================  
  
; Re-implemented interpret_line using read_token_and_cache  
  
; ============================================================  
  
; (This avoids “edit-in-place” issues.)  
  
interpret_line:  
  
               call    ds_clear  
  
               ld      hl, LINEBUF  
  
.il2_loop:  
  
               call    read_token_and_cache  
  
               jr      z, .il2_finish  
  
               ld      a, (TOKENBUF)  
  
               cp      '0'  
  
               jr      c, .il2_word  
  
               cp      '9'+1  
  
               jr      nc, .il2_word  
  
               call    parse_u16_token_to_hl  
  
               call    ds_push_hl  
  
               jr      .il2_loop  
  
.il2_word:  
  
               call    dict_find  
  
               jr      z, .unknown2  
  
               push    hl  
  
               push    de  
  
               pop     hl  
  
               call    call_hl  
  
               pop     hl  
  
               jr      .il2_loop  
  
.unknown2:  
  
               ld      de, str_unknown  
  
               call    bdos_printstr  
  
               ld      hl, TOKENBUF  
  
               call    print_cstr_0term  
  
               call    print_crlf  
  
               jr      .il2_loop  
  
.il2_finish:  
  
               ld      de, str_ans  
  
               call    bdos_printstr  
  
               call    ds_is_empty  
  
               jr      z, .no_ans2  
  
               call    ds_pop_hl  
  
               call    print_u16_hl  
  
.no_ans2:  
  
               ret  
  
; ============================================================  
  
; Primitive implementations (pure Z80)  
  
; ============================================================  
  
; PLUS: ( a b -- a+b )  
  
prim_plus:  
  
               call    ds_pop_hl       ; HL = b  
  
               ex      de, hl          ; DE = b  
  
               call    ds_pop_hl       ; HL = a  
  
               add     hl, de          ; HL = a+b  
  
               call    ds_push_hl  
  
               ret  
  
; ============================================================  
  
; Number parsing: TOKENBUF (decimal) -> HL  
  
; ============================================================  
  
parse_u16_token_to_hl:  
  
               ; HL=0; for each digit: HL = HL*10 + digit  
  
               ld      hl, 0  
  
               ld      de, TOKENBUF  
  
.pn1:  
  
               ld      a, (de)  
  
               or      a  
  
               ret     z  
  
               sub     '0'  
  
               ld      c, a            ; digit in C (0..9)  
  
               ; HL = HL*10 = HL*8 + HL*2  
  
               push    hl  
  
               add     hl, hl          ; *2  
  
               ex      de, hl          ; DE = HL*2, HL = tokenptr (oops)  
  
               ; restore cleanly:  
  
               ex      de, hl          ; HL back to *2, DE back tokenptr  
  
               pop     de              ; DE = old HL  
  
               push    hl              ; save *2  
  
               ld      hl, de          ; HL = old  
  
               add     hl, hl          ; *2  
  
               add     hl, hl          ; *4  
  
               add     hl, hl          ; *8  
  
               pop     de              ; DE = *2  
  
               add     hl, de          ; *10  
  
               ; HL += digit  
  
               ld      a, 0  
  
               ld      b, a  
  
               ld      a, c  
  
               ld      e, a  
  
               ld      d, 0  
  
               add     hl, de  
  
               inc     de              ; token pointer  
  
               jr      .pn1  
  
; ============================================================  
  
; Print 0-terminated C string at HL (uses BDOS CONOUT)  
  
; ============================================================  
  
print_cstr_0term:  
  
.pc1:  
  
               ld      a, (hl)  
  
               or      a  
  
               ret     z  
  
               call    putch  
  
               inc     hl  
  
               jr      .pc1  
  
; ============================================================  
  
; Print unsigned 16-bit in HL (decimal)  
  
; Simple div-by-10 loop with remainder collection  
  
; ============================================================  
  
print_u16_hl:  
  
               ; If HL=0 => print '0'  
  
               ld      a, h  
  
               or      l  
  
               jr      nz, .pu_go  
  
               ld      a, '0'  
  
               call    putch  
  
               ret  
  
.pu_go:  
  
               ; We'll push remainders (digits) to a small buffer  
  
               ld      ix, digit_buf_end  
  
.pu_divloop:  
  
               ; divide HL by 10 => quotient in HL, remainder in A (0..9)  
  
               call    div10_u16_hl  
  
               ; store remainder as ASCII in buffer backwards  
  
               add     a, '0'  
  
               dec     ix  
  
               ld      (ix+0), a  
  
               ; continue until quotient=0  
  
               ld      a, h  
  
               or      l  
  
               jr      nz, .pu_divloop  
  
               ; output buffer from ix to end  
  
.pu_out:  
  
               ld      a, (ix+0)  
  
               call    putch  
  
               inc     ix  
  
               ld      hl, digit_buf_end  
  
               or      a  
  
               sbc     hl, ix  
  
               jr      nz, .pu_out  
  
               ret  
  
; Divide HL by 10  
  
; OUT: HL=quotient, A=remainder  
  
div10_u16_hl:  
  
               ; classic restoring division (16-bit / 10)  
  
               ; remainder in A, quotient in HL  
  
               ld      de, 0           ; DE = quotient  
  
               ld      b, 16  
  
               ld      a, 0            ; A = remainder (8-bit is enough for /10 steps)  
  
.d10_loop:  
  
               ; shift left (remainder:HL) by 1  
  
               add     hl, hl          ; HL <<= 1, carry out  
  
               rla                     ; A = (A<<1) | carry  
  
               ; try subtract 10  
  
               cp      10  
  
               jr      c, .d10_no_sub  
  
               sub     10  
  
               ; set quotient bit = 1  
  
               inc     de  
  
.d10_no_sub:  
  
               ; shift quotient left by 1 each iteration:  
  
               ; easiest: rotate DE left with carry=bit just set?  
  
               ; We'll build quotient in DE by shifting and adding bit.  
  
               ; Approach: DE <<= 1; if subtract succeeded, set bit0=1.  
  
               ; But we used "inc de" wrong above. Let's do it properly:  
  
               ; --- rewrite within loop using carry flag ---  
  
               ; We'll implement quotient in DE by:  
  
               ;   DE <<= 1  
  
               ;   if (remainder>=10) remainder-=10, set carry=1 else carry=0  
  
               ;   then DE |= carry  
  
               ; Because we already did compare/sub, we can set carry accordingly.  
  
               ; (We must rework: easiest is to do DE shift first, then conditionally set bit0.)  
  
               ; This function is small; implement cleanly below.  
  
               ; (We will jump to clean version for correctness.)  
  
               jp      div10_u16_hl_clean  
  
; Correct, clean division implementation  
  
; IN: HL  
  
; OUT: HL=quot, A=rem  
  
div10_u16_hl_clean:  
  
               ld      de, 0           ; quotient  
  
               ld      a, 0            ; remainder (0..19 while processing)  
  
               ld      b, 16  
  
.d10c:  
  
               ; shift (A:HL) left by 1  
  
               add     hl, hl  
  
               rla  
  
               ; shift quotient left by 1  
  
               ex      de, hl  
  
               add     hl, hl  
  
               ex      de, hl  
  
               ; if remainder >= 10, remainder -= 10, set quotient bit0  
  
               cp      10  
  
               jr      c, .d10c_skip  
  
               sub     10  
  
               inc     de              ; set bit0 (since we already shifted left)  
  
.d10c_skip:  
  
               djnz    .d10c  
  
               ; move quotient DE -> HL  
  
               ex      de, hl  
  
               ret  
  
digit_buf:       ds      6              ; enough for 0..65535 (5 digits) + spare  
  
digit_buf_end:  
  
; ============================================================  
  
; Strings ($-terminated for BDOS 9)  
  
; ============================================================  
  
str_ok_prompt:   db      "OK> $"  
  
str_ans:         db      "ANS=$"  
  
str_unknown:     db      "?? $"  
  
; ============================================================  
  
; Dictionary generated by LUA  
  
; ============================================================  
  
dict_count:      db      0  
  
dict:  
  
; We generate:  
  
;   dict_count = N  
  
;   entries in dict:  
  
;     db len, "NAME", 0, dw code  
  
;  
  
; Only PLUS for this demo, but you can add more easily.  
  
LUA ALLPASS  
  
local words = {  
  
 { "+", "prim_plus" },  
  
}  
  
_pc("dict_count: db " .. #words)  
  
_pc("dict:")  
  
for _,w in ipairs(words) do  
  
 local name = w[1]  
  
 local code = w[2]  
  
 _pc("  db " .. #name)  
  
 _pc("  db " .. string.format("%q", name) .. ", 0")  
  
 _pc("  dw " .. code)  
  
end  
  
ENDLUA  
  
; ============================================================  
  
; End  
  
; ============================================================    
~~~
---  
  
## **ここからの拡張（次の一歩）**  
  
この雛形が動いたら、次は “Forth らしさ” を増やすのが簡単です。  
  
* .（トップを表示）を追加（辞書に . を入れて primitive 実装）    
* DUP DROP SWAP などスタック操作を追加（全部この枠で増やせます）    
* : ; に近づける（まずは “ワードを colon 定義風に列挙する” ところから）  
  
---  
  
もし「入力したForth文字列を *そのまま* 解釈して 2 3 + . みたいに動かしたい（.で出力、OK表示など）」まで一気に寄せたいなら、次の段階として  
  
* . を実装して、ANS=表示はやめて “通常Forth流” にする    
  もしくは    
* 今の ANS=出力を残しつつ、. も追加（両立）  
  
のどちらもすぐ作れます。どっち寄せが好みですか？（※確認だけ。あなたの好みが出るところなので）  
  
# あなた:  
  
基本となるモデルの提示をありがとうございます。    
先に進む前にPRIMS(X)について教えてもらいたいです。PRIMS(X)は    
~~~
	X(DUP,     "dup",     t=TOS; push(t); ) \    
~~~
のようなX(A, B, C)が７２行並んでいます。その中のCにあたる部分で実行手順が示されています。そこに書かれている”;"で区切られた「push()」や「pop()」、「t=xxx」達こそがLUAで記述されたマクロ定義実行部のマイクロコードだと感じています。これらのマイクロコードを分類してもらえませんか？  
  
~~~
#define PRIMS(X) \    
	X(DUP,     "dup",     t=TOS; push(t); ) \    
	X(SWAP,    "swap",    t=TOS; TOS=NOS; NOS=t; ) \    
	X(DROP,    "drop",    pop(); ) \    
	X(OVER,    "over",    t=NOS; push(t); ) \    
	X(LITC,    "lit,",    compileNumber(pop()); ) \    
	X(FET,     "@",       TOS = *(cell*)TOS; ) \    
	X(STO,     "!",       t=pop(); n=pop(); *(cell*)t = n; ) \    
	X(CFET,    "c@",      TOS = *(byte*)TOS; ) \    
	X(CSTO,    "c!",      t=pop(); n=pop(); *(byte*)t = (byte)n; ) \    
	X(PLSTO,   "+!",      t=pop(); n=pop(); *(cell*)t += n; ) \    
	X(ADD,     "+",       t=pop(); TOS += t; ) \    
	X(SUB,     "-",       t=pop(); TOS -= t; ) \    
	X(MUL,     "*",       t=pop(); TOS *= t; ) \    
	X(DIV,     "/",       t=pop(); TOS /= t; ) \    
	X(SLMOD,   "/mod",    t=TOS; n = NOS; TOS = n/t; NOS = n%t; ) \    
	X(INCR,    "1+",      ++TOS; ) \    
	X(DECR,    "1-",      --TOS; ) \    
	X(LT,      "<",       t=pop(); TOS = (TOS < t); ) \    
	X(EQ,      "=",       t=pop(); TOS = (TOS == t); ) \    
	X(GT,      ">",       t=pop(); TOS = (TOS > t); ) \    
	X(EXIT,    "exit",    if (0<rsp) { pc = rpop(); } else { return; } ) \    
	X(EQ0,     "0=",      TOS = (TOS == 0) ? 1 : 0; ) \    
	X(AND,     "and",     t=pop(); TOS &= t; ) \    
	X(OR,      "or",      t=pop(); TOS |= t; ) \    
	X(XOR,     "xor",     t=pop(); TOS ^= t; ) \    
	X(COM,     "com",     TOS = ~TOS; ) \    
	X(FOR,     "for",     lsp+=3; L0=0; L1=pop(); L2=pc; ) \    
	X(NDX_I,   "i",       push(L0); ) \    
	X(NEXT,    "next",    if (++L0<L1) { pc=L2; } else { lsp=(2<lsp)?(lsp-3):0; } ) \    
	X(TOR,     ">r",      rpush(pop()); ) \    
	X(RAT,     "r@",      push(rstk[rsp]); ) \    
	X(RFROM,   "r>",      push(rpop()); ) \    
	X(RDROP,   "rdrop",   rpop(); ) \    
	X(ATO,     ">a",      if (asp < STK_SZ) { astk[++asp] = pop(); } ) \    
	X(ASET,    "a!",      astk[asp] = pop(); ) \    
	X(AGET,    "a@",      push(astk[asp]); ) \    
	X(AGETI,   "a@+",     push(astk[asp]++); ) \    
	X(AGETD,   "a@-",     push(astk[asp]--); ) \    
	X(AFROM,   "a>",      push(0<asp ? astk[asp--]: 0); ) \    
	X(BTO,     ">b",      if (bsp < STK_SZ) { bstk[++bsp] = pop(); } ) \    
	X(BSET,    "b!",      bstk[bsp] = pop(); ) \    
	X(BGET,    "b@",      push(bstk[bsp]); ) \    
	X(BGETI,   "b@+",     push(bstk[bsp]++); ) \    
	X(BGETD,   "b@-",     push(bstk[bsp]--); ) \    
	X(BFROM,   "b>",      push(0<bsp ? bstk[bsp--]: 0); ) \    
	X(TTO,     ">t",      if (tsp < STK_SZ) { tstk[++tsp] = pop(); } ) \    
	X(TSET,    "t!",      tstk[tsp] = pop(); ) \    
	X(TGET,    "t@",      push(tstk[tsp]); ) \    
	X(TGETI,   "t@+",     push(tstk[tsp]++); ) \    
	X(TGETD,   "t@-",     push(tstk[tsp]--); ) \    
	X(TFROM,   "t>",      push(0<tsp ? tstk[tsp--]: 0); ) \    
	X(EMIT,    "emit",    emit((char)pop()); ) \    
	X(KEY,     "key",     push(key()); ) \    
	X(KEYQ,    "key?",    push(qKey()); ) \    
	X(OUTER,   "outer",   t=pop(); n=(cell)toIn; cfOuter((char*)t); toIn=(char*)n; ) \    
	X(ADDWORD, "addword", addWord(0); ) \    
	X(NXTWORD, "nextword",nextWord(); push((cell)wd); ) \    
	X(FIND,    "find",    { DE_T *dp=findWord(0); push(dp?dp->xt:0); push((cell)dp); } ) \    
	X(CLK,     "timer",   push(timer()); ) \    
	X(MS,      "ms",      ms(pop()); ) \    
	X(ZTYPE,   "ztype",   zType((const char *)pop()); ) \    
	X(FOPEN,   "fopen",   t=pop(); TOS=fOpen(TOS, t); ) \    
	X(FCLOSE,  "fclose",  t=pop(); fClose(t); ) \    
	X(FREAD,   "fread",   t=pop(); n=pop(); TOS=fRead(TOS, n, t); ) \    
	X(FWRITE,  "fwrite",  t=pop(); n=pop(); TOS=fWrite(TOS, n, t); ) \    
	X(FSEEK,   "fseek",   t=pop(); n=pop(); fSeek(t,n); ) \    
	X(SYSTEM,  "system",  t=pop(); ttyMode(0); system((char*)t); ) \    
	X(SCOPY,   "s-cpy",   t=pop(); strcpy((char*)TOS, (char*)t); ) \    
	X(SEQI,    "s-eqi",   t=pop(); n=pop(); push(strEqI((char*)n, (char*)t)); ) \    
	X(SLEN,    "s-len",   TOS=strlen((char*)TOS); ) \    
	X(CMOVE,   "cmove",   t=pop(); n=pop(); memmove((char*)n, (char*)pop(), t); ) \    
	X(BYE,     "bye",     ttyMode(0); exit(0); )  
  
enum { STOP, LIT, JMP, JMPZ, NJMPZ, JMPNZ, NJMPNZ, PRIMS(X1) };  
~~~
  
# ChatGPT:  
  
いい着眼です。PRIMS の「C 部分」はまさに **VM の“マイクロコード（スタック機械の手続き列）”**で、Z80 化するときも この粒度（push/pop/TOS/NOS/pc/rsp…）を部品化できるかが鍵になります。  
  
ここでは、あなたが貼った 72 行の C 部分に出てくる “原始動作” を、**再利用しやすいマイクロ命令（micro-ops）**として分類します。    
（※分類は「実装上のまとまり」と「Z80化で部品になる単位」を優先しています）  
  
---  
  
## **A. データスタック基本マイクロ命令（DS）**  
  
核になる micro-op  
  
* push(x)：データスタックに push    
* pop()：データスタックから pop（多くは TOS に反映）    
* TOS：トップ（Top Of Stack）レジスタ/変数    
* NOS：次（Next On Stack）＝スタックの 2 番目（CF 実装だと “TOS の下” を直参照できる想定）  
  
この系の典型パターン  
  
* 複製/移動    
  * t=TOS; push(t);（DUP）    
  * t=NOS; push(t);（OVER）    
  * TOS=NOS; NOS=t;（SWAP の中心）    
* 破棄    
  * pop();（DROP）  
  
Z80化のコア：    
「TOS を HL に置く」＋「NOS をメモリから読む/書く」＋「push/pop の短い部品」をまず確立。  
  
---  
  
## **B. 算術・比較・論理（ALU）**  
  
共通 micro-op 形  
  
* 二項演算の多く：t=pop(); TOS op= t;    
  * t=pop(); TOS += t;（+）    
  * t=pop(); TOS -= t;（-）    
  * t=pop(); TOS *= t;（*）    
  * t=pop(); TOS /= t;（/）    
  * t=pop(); TOS &= t;（and）    
  * t=pop(); TOS |= t;（or）    
  * t=pop(); TOS ^= t;（xor）    
  * t=pop(); TOS = (TOS < t);（<）    
  * t=pop(); TOS = (TOS == t);（=）    
  * t=pop(); TOS = (TOS > t);（>）  
  
単項  
  
* ++TOS;（1+）    
* --TOS;（1-）    
* TOS = ~TOS;（com）    
* TOS = (TOS == 0) ? 1 : 0;（0=）  
  
特殊（2結果）  
  
* /mod：t=TOS; n=NOS; TOS=n/t; NOS=n%t;    
  → “TOS と NOS を同時に更新する”系。Z80だと分岐/除算ルーチンが必要。  
  
Z80化の部品：    
POP_TO_DE（pop を DE へ）＋ HL op DE が基本パターン。  
  
---  
  
## **C. メモリアクセス（MEM）**  
  
共通 micro-op  
  
* 読み：TOS = *(type*)TOS;    
  * @：cell 読み    
  * c@：byte 読み    
* 書き：addr と value の取り方が一定    
  * t=pop(); n=pop(); *(cell*)t = n;（!）    
  * t=pop(); n=pop(); *(byte*)t = (byte)n;（c!）    
  * t=pop(); n=pop(); *(cell*)t += n;（+!）  
  
Z80化の部品：    
「アドレス＝HL か DE か」規約を決めて、    
LOAD16 [addr] -> HL / STORE16 HL -> [addr] / byte版 を揃える。  
  
---  
  
## **D. コンパイル支援・リテラル（COMP）**  
  
CF っぽい「実行しながら辞書を伸ばす」側。  
  
* compileNumber(pop());（lit,）    
  * これは **“コンパイラ/辞書生成”**系で、純粋な VM 命令というより「ホスト関数呼び出し」。  
  
Z80化：    
ここは「辞書形式」「コンパイル時のメモリ管理」を決める段でまとめて移植。  
  
---  
  
## **E. 制御フロー（PC / VM制御）**  
  
VM の命令ポインタ pc を操作する系。  
  
* EXIT：if (0<rsp) { pc=rpop(); } else { return; }    
  * リターンスタック（rsp/rpop）と VM の実行ループに直結。    
* （あなたが貼った一覧では JMP 系は enum にはあるけど PRIMS には見えてない＝VMの別層かも）  
  
Z80化の部品：    
pc の表現（HL? メモリ上?）と NEXT の書き方が最優先で固めるところ。  
  
---  
  
## **F. ループ制御（FOR/NEXT と Lスタック）**  
  
CF独自っぽい簡易ループの“内部スタック”が見えるところ。  
  
* FOR: lsp+=3; L0=0; L1=pop(); L2=pc;    
* i: push(L0);    
* NEXT: if (++L0<L1) pc=L2; else lsp=(2<lsp)?(lsp-3):0;  
  
ここでの micro-op は：  
  
* Lフレーム確保（lsp+=3）    
* カウンタ初期化（L0=0）    
* 上限取得（L1=pop()）    
* 戻り先保存（L2=pc）    
* 反復判定（++L0 < L1）    
* pc 巻き戻し or フレーム解放  
  
Z80化：    
これは「第3のスタック」（Lスタック）なので、最初は後回しでOK。    
でも分類としては **“ループ・フレーム操作”**で独立。  
  
---  
  
## **G. 追加スタック群（R / A / B / T）**  
  
CF はデータスタック以外に複数のスタックを持つのが特徴。  
  
### **G1) リターンスタック（R）**  
  
* >r: rpush(pop());    
* r@: push(rstk[rsp]);    
* r>: push(rpop());    
* rdrop: rpop();  
  
micro-op：  
  
* R_PUSH(x) / R_POP() / R_PEEK()  
  
### **G2) A/B/T スタック（汎用レジスタスタック）**  
  
パターンがほぼ同形：  
  
* >a: astk[++asp]=pop()    
* a!: astk[asp]=pop()    
* a@: push(astk[asp])    
* a@+: push(astk[asp]++)    
* a@-: push(astk[asp]--)    
* a>: push(0<asp ? astk[asp--] : 0)  
  
同様に b*, t* がある。  
  
micro-op：  
  
* X_PUSH(pop())（>a 等）    
* X_SET(pop())（a!）    
* X_GET()（a@）    
* X_GET_POSTINC/POSTDEC（a@+/a@-）    
* X_POP_OR0()（a>）  
  
Z80化：    
この “同形” はまさに LUA生成が効くところ。    
「A/B/T のどれか」と「配列ベース」「sp変数」だけが違う。  
  
---  
  
## **H. 端末I/O（IO）**  
  
* emit((char)pop());    
* push(key());    
* push(qKey());    
* ztype((const char*)pop());  
  
micro-op：  
  
* CALL_HOST_IO(...)（外部関数呼び出し）    
* POP arg / PUSH result の定形  
  
MSX化：    
emit/key は BDOS 呼び出しに置換しやすい。ztype は $終端/0終端の取り扱いを決める。  
  
---  
  
## **I. 外側インタプリタ・辞書操作（OUTER / DICT）**  
  
CFの「C側の外側」を直接呼ぶ系。  
  
* outer: t=pop(); n=(cell)toIn; cfOuter((char*)t); toIn=(char*)n;    
* addword: addWord(0);    
* nextword: nextWord(); push((cell)wd);    
* find: { dp=findWord(0); push(dp?dp->xt:0); push((cell)dp); }  
  
micro-op：  
  
* VMの外（C関数）に制御移譲    
* その前後で toIn などインタプリタ状態保存/復元  
  
MSX化：    
あなたの構想（main を WORD にする）に一番関係する層。    
ここを “ワード化” するか “内蔵ルーチン化” するかで設計が決まります。  
  
---  
  
## **J. タイマ・待ち（TIME）**  
  
* push(timer());    
* ms(pop());  
  
micro-op：  
  
* CALL_HOST_TIME() / SLEEP(n)  
  
---  
  
## **K. ファイル/OS/文字列/メモリ移動（HOST/OS/LIB）**  
  
これは **VM命令というより「ホスト関数バインディング」**です。  
  
* file: fopen/fclose/fread/fwrite/fseek    
* system/ttyMode    
* string: strcpy/strlen/strEqI    
* memory: memmove    
* bye: exit(0)  
  
micro-op：  
  
* POP args...; CALL host; PUSH result(if any)  
  
MSX-DOS でも一部は BDOS/FAT で似せられますが、最初のCF-MSX最小系では後回しが吉。  
  
---  
  
# **まとめ：C部は「micro-op の組み合わせ」になっている**  
  
あなたの言う通り、C部は  
  
* (1) DS micro-op（push/pop/TOS/NOS）    
* (2) ALU micro-op    
* (3) PC/R/L/A/B/T など“状態スタック micro-op”    
* (4) host call micro-op（I/O, outer, file, libc）  
  
の組み合わせでできています。  
  
---  
  
## **CF-MSXで “最初に移植すべき micro-op セット”**  
  
あなたの目標（キー入力→数値足し算→ANS=表示）だけなら、最低限はこれだけで足ります：  
  
1. DS：push, pop, （TOS扱い）    
2. ALU：+    
3. I/O：key（または行入力）, emit（または文字列出力）    
4. 外側：tokenize、数値化、word lookup（ここは “outer” 相当）  
  
つまり、PRIMS全部をいきなり移植せず、分類の A+B+H+I だけ先に実装が一番早いです。  
  
---  
  
必要なら次の返事で、上の分類をそのまま **「Z80向け micro-op 部品表」**に落とします：  
  
* 例：t=pop(); TOS += t; を Z80でどういう定形にするか（HL/TOSキャッシュ版、非キャッシュ版の2案）    
* TOS/NOS をどう表すと SWAP/OVER が最短になるか    
* A/B/T スタック群を Lua 生成するテンプレ（同形なので一気に自動化できます）  
  
どれから欲しいですか？（確認が要るほど曖昧ではないので、次は私の方で HL=TOSキャッシュ案をデフォルトにして micro-op 化表を提示してもOKです）  
  
# あなた:  
  
ここで確認しなくてはならないことがあります。AからKまで分析してもらいました。私が気にしていることを述べます。  
  
B. 算術・比較・論理（ALU）    
　→Z80は除算命令や乗算命令がないので、どう対応するのか？CFのPRIMSの中で除算命令や乗算命令を使っていないのなら問題ないが。  
  
~~~
　　　t=pop(); TOS *= t;（*）    
　　　t=pop(); TOS /= t;（/）  
~~~
  
D. コンパイル支援・リテラル（COMP）    
　　CF っぽい「実行しながら辞書を伸ばす」側。    
　　　　compileNumber(pop());（lit,）    
　→ここはPRIMSからどう展開して辞書を作成しているのかを知らないといけません。これからの作業をやりやすくするために、CF.Cやsystem.cでどのように処理されているか教えてください。  
  
I. 外側インタプリタ・辞書操作（OUTER / DICT）    
　micro-op：    
　　VMの外（C関数）に制御移譲    
　　その前後で toIn などインタプリタ状態保存/復元    
　MSX化：    
　　あなたの構想（main を WORD にする）に一番関係する層。    
　　ここを “ワード化” するか “内蔵ルーチン化” するかで設計が決まります。    
K. ファイル/OS/文字列/メモリ移動（HOST/OS/LIB）    
~~~
　micro-op：    
　　POP args...; CALL host; PUSH result(if any)    
　　MSX-DOS でも一部は BDOS/FAT で似せられますが、最初のCF-MSX最小系では後回しが吉。  
~~~
  
　→このIとKはFORTHらしく、VM以外は初期化の短いルーチン以外はすべてWORD化したいです。この項「CF MSXのPRIMS定義方法」で分類していやだいている理由がそこにあります。私の理解では72 行の C 部分さえ押さえてしまえば（すべてWORDに落とし込めば）FORTHはできたも同然だと思っていましたが、そう甘くはないのかもしれないなぁ、が私の感覚です）  
  
で、最終的に「まとめ：C部は「micro-op の組み合わせ」になっている」がうまくいくためには、ほぼすべてがWORDで実現できるかがカギです。具体的にはMSXのファンクションコール（c-bios？）をうまく使って、全部のWORDが実現できるかです。できない部分があるならそれは何かが知りたいです。  
  
# ChatGPT:  
  
思考時間: 40s  
  
了解です。あなたが「確認しなくてはならない」と言っているポイントは、まさに **CF→Z80(MSX) 移植の“設計の分岐点”**です。順に、できるだけ具体的に答えます。  
  
---  
  
## **1) B. ALU（* と /）— Z80に乗算/除算命令が無い問題**  
  
結論：CF の t=pop(); TOS *= t; / TOS /= t; を Z80 で“そのまま”は無理なので、次のどれかになります。  
  
### **選択肢A：ソフトウェアルーチン化（普通はこれ）**  
  
* * 用に mul16（16bit×16bit→16bit or 32bit）を用意    
* / 用に div16（16bit÷16bit→商16bit 余り16bit）を用意    
* Z80の * / / primitive は「popして、ルーチン呼んで、pushする」だけにする  
  
CF の PRIMS の C 部分は “Cの演算子” なので、ホストCPUが勝手に mul/div 命令を使ってくれますが、Z80ではあなたが用意します。  
  
### **選択肢B：最小系では “未実装” にする**  
  
MSX版の初期デモを「足し算だけ」で回すなら、* / /mod を後回しにして問題ありません。    
（あなたの目標「入力→足し算→ANS=表示」には不要）  
  
### **選択肢C：セル幅/符号を割り切る**  
  
* 16bit unsignedだけに限定して、ルーチンを簡単にする    
* signedが必要になったら後から拡張  
  
重要：/mod は TOS=n/t; NOS=n%t; のように 商と余りを同時に出すので、結局 div ルーチンが必要になります。  
  
---  
  
## **2) D.** lit, **と** compileNumber(pop()) **— PRIMSから辞書がどう伸びるのか**  
  
ここは、あなたの言う通り CF.c / system.c の流れ（辞書構造とコンパイラ）が分からないと移植設計が決まりません。  
  
ただ、あなたが貼ってくれた PRIMS 断片と、CF系（Cで書かれた小型Forth）の典型設計から、かなり高確度で “何をしているか” を分解できます（※手元にCFのソース全文が無いので、関数名や変数名はあなたの貼ったものに合わせ、細部は「一般的なCF設計の推定」を含みます）。  
  
### **CFの起動～辞書生成の基本ストーリー（典型）**  
  
1. main() で    
   * 端末設定（ttyMode()）やメモリ確保    
   * スタック/ポインタ初期化（here/last/toIn/base/state 等）    
   * PRIMSで定義された primitive 群を辞書に登録（または最初から辞書配列として持つ）    
2. その後    
   * 起動時のForthテキスト（ブートストラップ）を cfOuter() に食わせる    
     → : ; if begin などの高級ワードが “Forthでコンパイルされて辞書が増える”    
3. 以後、ユーザー入力を cfOuter() が解釈して実行/コンパイルする  
  
### lit,**（compileNumber）の役割**  
  
lit, は「（いまコンパイル中の定義に）数値リテラルを埋め込む」ための低級コンパイル語です。  
  
だいたいこういう動作になります：  
  
* compileNumber(n) は辞書に    
  1. “LIT opcode（または LIT の xt）”    
  2. “数値 n（セル1個）”    
     を順番に書き込む  
  
つまり : foo 123 ; の 123 を見つけた時、  
  
* インタプリタが「数値だ」と判断    
* state=compile なら    
  * compileNumber(123) を呼び、辞書に LIT と 123 を積む    
* state=interpret なら    
  * ただ push(123) する  
  
この「interpret時はpush」「compile時はcompileNumber」が、CF系の基本です。  
  
ここで注意：あなたの enum に LIT, JMP, JMPZ ... が PRIMSより前にありますよね。    
つまり CFは “PRIMSだけ” では完結していなくて、LIT/JMP系は VM命令（スレッドコード）側の別枠として存在します。    
これが「72行のC部だけ押さえても、まだ足りない」最大の理由です。  
  
---  
  
## **3) I と K を “全部WORD化” したい — どこまで可能か？**  
  
あなたの方針はとてもForthらしいです。結論を先に言うと：  
  
* 「I/Kの“機能”はほぼ全部WORD化できる」    
* ただし 「WORDとして呼び出せるようにする“橋（callgate）”」だけは、少数のプリミティブ（VM外の実装）が必要    
* さらに “inner interpreter（NEXT/dispatch）” と “辞書の最小操作” はWORDだけでは生えない（最初の卵問題）  
  
という形になります。  
  
### **3.1 “WORD化できる”もの（I/Kの大半）**  
  
* emit/key/ztype などのI/Oは、最終的には WORDとして見せられる    
* ファイル/OS/文字列も、最終的には WORDとして見せられる  
  
ただしそのために、下の「できない（WORDだけでは完結しない）部分」を土台として用意します。  
  
### **3.2 “WORDだけでは完結しない”部分（MSXでも必ず残る最小核）**  
  
あなたが知りたい「できない部分」は、だいたいこの5種類です。  
  
#### **(1) 内部実行エンジン（NEXT / dispatch）**  
  
* スレッドコード（token-threaded 等）を読む    
* opcode/xt を取り出して飛ぶ    
* pc を進める  
  
これは **“ワードを実行するための機械”**なので、ワードで書けません（書く前に実行機構が必要）。  
  
#### **(2) データスタック/リターンスタックの最低限**  
  
* push/pop と rpush/rpop の最小セット    
* EXIT（リターン）や分岐で必須  
  
#### **(3) 分岐/リテラル（LIT, JMP, 0BRANCH等のVM命令）**  
  
あなたの enum にある LIT/JMP/... はここ。    
これが無いと コロン定義やIF/LOOPが成立しないので、最初から必要です。  
  
#### **(4) “ホスト呼び出しの橋”（BDOS/BIOS callgate）**  
  
I/Kを全部WORD化するためには、「WORDからBDOS/BIOSを呼ぶ」必要があります。    
その呼び方は最終的に  
  
* 固定機能のプリミティブ（EMIT は BDOS2、KEY は BDOS1…）    
  * これは簡単で最小    
* あるいは    
* 汎用 callgate（「アドレスとレジスタ引数を渡して任意のBIOS/BDOSを呼ぶ」）    
  * これは強力だけど設計が要る  
  
どちらにしても “callgate自体” は VM外（Z80コード）として残ります。  
  
#### **(5) ブートストラップ（最初の辞書生成）**  
  
「全部WORD化」は最終形としては可能でも、最初に WORD を増やすための最小コンパイラ部分が必要です。  
  
* 数値のパース    
* 最低限の : ; のコンパイル動作    
* FIND と EXECUTE 的なもの  
  
ここをどこまでZ80側に置き、どこからForthで育てるかが設計になります。  
  
---  
  
## **4) 「72行のC部を全部WORDに落とせばForth完成」ではない理由**  
  
まさにここが落とし穴で、あなたの感覚は正しいです（甘くない）。  
  
理由は2つ：  
  
1. PRIMS以外の“VM命令（LIT/JMP/BRANCH）”が別にある    
   → あなたの enum がそれを示しています。    
2. PRIMSのC部には “ホスト関数呼び出し” と “インタプリタ状態操作（toIn等）” が混ざっている    
   → これは「CPUの命令」ではなく「処理系の都合」なので、移植時に“層”を分けないと破綻しやすい。  
  
---  
  
## **5) MSXで「ほぼすべてをWORDで」うまくいかせる現実的な設計**  
  
あなたの方針に沿う、現実的な落とし所はこれです：  
  
* Z80（VM外）に残す最小核    
  * NEXT/dispatch（inner interpreter）    
  * DS/RS の push/pop    
  * LIT/JMP/BRANCH/EXIT などのVM命令    
  * BDOS/BIOS呼び出しの“橋”（最小でも EMIT/KEY、可能なら汎用callgate）    
* それ以外は、順次WORD化    
  * outer interpreter（トークン分解、FIND、数値解釈、stateでcompile/interpret切替）    
  * 辞書操作（addWord等）    
  * 文字列/メモリユーティリティ    
  * ファイル/OS  
  
この形なら、「72行のC部」を“目標としてWORD化”していく道筋が立ちます。  
  
---  
  
## **次にやると一気に見通しが良くなること**  
  
あなたが求めている「CF.c / system.c の具体」を、こちらで曖昧にせずに説明するには **CFの実物（該当関数の抜粋）**が必要です。いま web ではそのCFのソースを特定できませんでした（検索しても一致が出ませんでした）。  
  
なので、次のどちらかを貼ってください（短くてOK）：  
  
* compileNumber() の本体    
* cfOuter() の本体（toInの扱いが見えるところ）    
* nextWord() と、findWord() / addWord() のシグネチャ付近  
  
それがあれば、**「このCのここはZ80核に残す／これはWORD化できる／これはcallgateが必要」**を、あなたのCF実装そのものに即して、1行単位で分類し直して提示できます。  
  
貼れない場合でも進められるように、こちらで「典型CFの構造」を前提にした WORD化ロードマップ（第0段＝最小核、第1段＝outerをWORD化、第2段＝辞書操作をWORD化…）も作れます。  
  
# あなた:  
  
cf-main (1).zip  
  
Zip アーカイブ    
cfのソースコードを添付しておきますね。  
  
ここで確認しなくてはならないことがあります。AからKまで分析してもらいました。私が気にしていることを述べます。  
  
B. 算術・比較・論理（ALU）    
　→Z80は除算命令や乗算命令がないので、どう対応するのか？CFのPRIMSの中で除算命令や乗算命令を使っていないのなら問題ないが。  
  
~~~
　　　t=pop(); TOS *= t;（*）    
　　　t=pop(); TOS /= t;（/）  
~~~
  
D. コンパイル支援・リテラル（COMP）    
　　CF っぽい「実行しながら辞書を伸ばす」側。    
~~~
　　　　compileNumber(pop());（lit,）    
~~~
　→ここはPRIMSからどう展開して辞書を作成しているのかを知らないといけません。これからの作業をやりやすくするために、CF.Cやsystem.cでどのように処理されているか教えてください。  
  
I. 外側インタプリタ・辞書操作（OUTER / DICT）    
　micro-op：    
　　VMの外（C関数）に制御移譲    
　　その前後で toIn などインタプリタ状態保存/復元    
　MSX化：    
　　あなたの構想（main を WORD にする）に一番関係する層。    
　　ここを “ワード化” するか “内蔵ルーチン化” するかで設計が決まります。    
K. ファイル/OS/文字列/メモリ移動（HOST/OS/LIB）    
~~~
　micro-op：    
　　POP args...; CALL host; PUSH result(if any)    
　　MSX-DOS でも一部は BDOS/FAT で似せられますが、最初のCF-MSX最小系では後回しが吉。  
~~~
  
　→このIとKはFORTHらしく、VM以外は初期化の短いルーチン以外はすべてWORD化したいです。この項「CF MSXのPRIMS定義方法」で分類していやだいている理由がそこにあります。私の理解では72 行の C 部分さえ押さえてしまえば（すべてWORDに落とし込めば）FORTHはできたも同然だと思っていましたが、そう甘くはないのかもしれないなぁ、が私の感覚です）  
  
で、最終的に「まとめ：C部は「micro-op の組み合わせ」になっている」がうまくいくためには、ほぼすべてがWORDで実現できるかがカギです。具体的にはMSXのファンクションコール（c-bios？）をうまく使って、全部のWORDが実現できるかです。できない部分があるならそれは何かが知りたいです。  
  
# ChatGPT:  
  
思考時間: 3m 59s  
  
添付ありがとう！いま zip の中の cf.c と system.c を実際に読んだ上で、あなたが気にしている B/D/I/K を **「CFが実際にどう動いているか」**に即して整理します（推測ではなく、コードに書いてある通り）。  
  
---  
  
## **1) B. 乗算** * **と除算** / **— CFでは“使っている”ので、Z80では対応が必要**  
  
cf.c の PRIMS に、あなたが貼った通り MUL/DIV/SLMOD が実装されています。  
  
* X(MUL, "*", t=pop(); TOS *= t; )    
* X(DIV, "/", t=pop(); TOS /= t; )    
* X(SLMOD, "/mod", t=TOS; n=NOS; TOS=n/t; NOS=n%t; )  
  
CF側は C なので * / % がそのまま使えますが、Z80 には命令がありません。  
  
### **Z80側の現実的な落とし所（3択）**  
  
1. 最小系では未実装でOK    
   まず + まで動かす（あなたの目標は足し算確認なので問題なし）    
2. ソフトウェアルーチンを primitive として持つ（おすすめ）    
   mul16, div16, divmod16 を Z80 で用意して、* / /mod のワードはそれを呼ぶだけにする    
3. Forthで書く（可能だが“育つまで”が必要）    
   +, and, xor, shift, if/loop が揃えば Forthで * や / を作れますが、    
   そのためには先に 分岐とループ（LIT/JMP系） が動く必要があります（後述）。  
  
---  
  
## **2) D.** lit,**（**compileNumber(pop())**）は「辞書へ何を書いているか」**  
  
cf.c の実装はこうです（ほぼそのまま要約）：  
  
* comma(n) は **コード領域 code[] の here に 1セル書いて here++**するだけ    
  （static void comma(cell n) { code[here++] = n; }）    
* compileNumber(n) は 数値を“圧縮して1セルで埋める”か、LIT命令＋値の2セルで埋める    
* if (btwi(n, 0, NUM_MASK)) { comma(n | NUM_BITS); }    
* else { comma(LIT); comma(n); }  
  
ここが重要で、CFのVMは「命令セル」の中に 小さい即値数を埋め込む仕組みを持っています。  
  
### **つまり** lit, **のマイクロコードは：**  
  
* コンパイル中の定義へ    
  * 小さい数なら NUM_BITS|n を 1セル書く    
  * 大きい数なら LIT と n を 2セル書く  
  
---  
  
## **3) そもそも「辞書」がどう作られているか（cfInit と PRIMS の関係）**  
  
### **3.1 CFの辞書エントリ（DE_T）は “末尾から手前に伸びる”**  
  
addWord() が分かりやすいです：  
  
* 辞書領域は mem[] の上端から下へ伸びる    
* last -= sizeof(DE_T); してそこに DE_T を作る    
* dp->xt = here;（そのワードの実行先は code[] の here）    
* dp->name に名前を入れる  
  
### **3.2 ただし primitive は “xt=コードアドレス” ではない**  
  
cfInit() の最後で PRIMS を辞書に登録しています：  
  
* PRIM_T prims[] = { PRIMS(X3) {0,0,0} }; で {op,name,0} の配列を作る    
* それをループして addWord(prims[i].name)->xt = prims[i].op;  
  
つまり primitive の xt には code のアドレスではなく “opcode番号（enum）” が入ります。  
  
---  
  
## **4) I. outer/辞書操作（あなたが“全部WORD化したい”層）が、CFではどう分離されているか**  
  
CFは「外側」と「内側」を完全に分けています。  
  
### **4.1 内側（inner interpreter）＝** cfInner(pc)  
  
cfInner は code[pc++] を読み、switch(ir) で実行します。  
  
* VM命令として STOP/LIT/JMP/JMPZ/JMPNZ/NJMPZ/NJMPNZ が “PRIMSとは別枠”で存在    
* その後に PRIMS(X2) が展開されて primitive が大量に case として入る    
* default は    
  * 小即値なら push（(ir & NUM_BITS) == NUM_BITS の圧縮即値）    
  * それ以外は「コロン定義呼び出し」扱いで return stack に戻り先を積んで pc=ir  
  
ここが、あなたの言う「72行のC部だけ押さえればForth完成」ではない最大の理由です。    
PRIMS以外の VM命令（LIT/JMP類）と、defaultの“コロン呼び出し規約”が別に必要です。  
  
### **4.2 外側（outer interpreter）＝** cfOuter(src)  
  
cfOuter は  
  
1. toIn を入力文字列にセット    
2. nextWord() でトークンを切り出し    
3. isStateChange() で : ; [ ] (コメント) を処理    
4. 数値なら    
   * state==COMPILE のとき compileNumber(pop())    
   * state==INTERP のとき isNumber() が push しただけで終了    
5. 数値でなければ findWord(wd)    
6. 見つかったら    
   * state==INTERP なら executeWord(dp)    
   * state==COMPILE なら compileWord(dp)  
  
となっています。  
  
### **4.3** executeWord **が面白い（“callgate”の最小形）**  
  
~~~
code[17] = dp->xt;  
  
code[18] = STOP;  
  
cfInner(17);  
~~~
  
つまり「1命令だけ置いた小さなスレッド」を作って inner を回しているだけです。  
  
これ、Z80化でもかなり使えます：  
  
* 「WORDの実行」は「ミニスレッドを作って inner に投げる」で統一できる  
  
---  
  
## **5) K. ホスト呼び出しを全部WORD化できるか？ —— “機能としては可能”、ただし「橋」は必要**  
  
あなたの結論の方向性は正しくて、  
  
* I/Kの“機能”はWORDとして提供できます    
* ただし WORDから MSX-DOS/BIOS を呼ぶための“橋（callgate）”は、最低限 VMの外に必要です  
  
CFでも同じで、emit/key/fopen/... は最終的に C関数呼び出しで実現されています。  
  
MSXでも同様に：  
  
* EMIT = BDOS 2    
* KEY = BDOS 1    
* ZTYPE = 自前ループで EMIT を回す（0終端 or $終端を選ぶ）    
* ファイル = BDOSのFCB/ハンドル系を使う or 最初は無し  
  
にできますが、「BDOSを呼ぶ1箇所」は Z80コードとして必要です。  
  
---  
  
## **6) 「ほぼ全部WORD化」を邪魔する “できない部分” は何か（結論）**  
  
あなたの質問にストレートに答えると、MSXであっても WORDだけでは成立しない（＝VM外に残る）ものは、CFの構造上この4つです。  
  
1. inner interpreter（NEXT/dispatch）    
   ワードを実行するための機械なので、ワードで書けない    
2. 最小のスタック操作（push/pop と return stack）    
   inner と分岐の基盤    
3. VM命令（少なくとも LIT と BRANCH 系）    
   CFでは PRIMSの外側に LIT/JMP/JMPZ/... が存在するのが証拠    
4. ホスト呼び出しの橋（BDOS/BIOS callgate）    
   I/KをWORD化するほど、むしろここが重要になる  
  
逆に言うと、上の4つを“核”として Z80で用意できれば、あなたの理想どおり  
  
* outer（nextWord/isNumber/find/compile/…）    
* 文字列・メモリ・ファイル・OS    
* さらに * / すら（ループが揃えば）Forthで  
  
を 段階的にWORD化していけます。  
  
---  
  
## **次に進める最短ルート（おすすめの手順）**  
  
あなたの目的（MSXで「入力→足し算→ANS=」確認）と、理想（I/KもWORD化）を両立するには：  
  
1. Z80核：STOP/LIT/BRANCH/0BRANCH/EXIT + push/pop + NEXT    
2. 最低I/Oワード：emit と key だけは callgate経由で primitive でもOK    
3. outer をWORD化する前に、CFの cfOuter 相当をまず Z80で動かして挙動確認    
4. 動いたら outer の部品（tokenize/number/find/execute/compile）を順にWORD化  
  
---  
  
もしよければ、次はあなたの「全部WORD化したい」方針に合わせて、CFの実装をそのまま写像した  
  
* MSX版の“最小核に残すべき命令セット”一覧    
* それ以外をWORDに落とすための callgate設計（EMIT/KEYの最小版、汎用版の2案）    
* そして compileNumber と “圧縮即値(NUM_BITS)” を MSXでどう扱うか（残す/捨てるの設計選択）  
  
を、具体的なZ80設計として提示します。  
  
まず確認したいのは1点だけ（ここが分岐点なので）：    
CFの「小さい数を1セルに埋め込む（NUM_BITS/NUM_MASK）」方式を、MSX版でも残したいですか？  
  
* 残す：高速・省メモリだが VM命令デコードが少し複雑    
* 捨てる：常に LIT n にして単純化（Z80の実装が楽、速度は少し落ちる）  
  
（質問はこれだけで大丈夫です。返事をもらえれば、その前提で“核＋WORD化ロードマップ”をZ80コード形に落とします。）  
  
# あなた:  
  
私が一番気にしているのが、「学生時代にZ80でコードを書いたことはあるが、MSXのZ80コードで処理系を書いたことがない」です。ここは、理解するためにかなりの時間が必要です。いまは「CFがMSX0で動かすためにはどうすればいいのだろうか。障害は何か？」が最優先で知りたいです。    
そのために、乱暴ですが、「MSXであっても WORDだけでは成立しない（＝VM外に残る）ものは、CFの構造上この4つです。」を具体的にMSX0でテストをする前提でasmファイルにソースコード化できますか？  
  
# ChatGPT:  
  
思考時間: 28s  
  
できます。ここではあなたの「MSX0でテストする前提」で、  
  
WORDだけでは成立しない（＝VM外に残る）4つ  
  
1. inner interpreter（NEXT/dispatch）    
2. 最小スタック（push/pop + return stack）    
3. VM命令（LIT/BRANCH/EXITなど）    
4. ホスト呼び出しの橋（BDOS/BIOS callgate）  
  
…を 1本の MSX-DOS .COM 用 Z80 asmとして“具体化”します。  
  
### **目的（このカーネルでMSX0上で確認できること）**  
  
* VM が LIT / ADD / EXIT / CALL / JMP/JMPZ を解釈して動く    
* VM から BDOS(CONOUT/CONIN) を呼んで EMIT/KEY が動く    
* 最小の“スレッド（命令列）”を実行して ANS=5 が表示できる    
  （数値表示は「1桁限定」にして、除算不要にしています）  
  
---  
  
# cf_msx0_kernel.asm**（最小核 4点セットの実コード）**  
  
sjasmplus でそのまま COM を作れます。    
~~~
sjasmplus --raw=cf_msx0_kernel.com cf_msx0_kernel.asm  
~~~
  
~~~
; ============================================================  
  
; CF-MSX0 Kernel Prototype (MSX-DOS .COM)  
  
;  - "VM外に残る最小核" を具体化したテスト用カーネル  
  
;    (1) inner interpreter: FETCH/DECODE/DISPATCH (NEXT)  
  
;    (2) data stack / return stack  
  
;    (3) VM opcodes: STOP, LIT, CALL, EXIT, JMP, JMPZ  
  
;    (4) BDOS callgate: EMIT, KEY  
  
;  
  
; Demo:  
  
;   Runs a tiny thread that computes 2 3 + and prints "ANS=5"  
  
; ============================================================  
  
               org     0100h  
  
               jp      start  
  
; -----------------------------  
  
; MSX-DOS BDOS entry  
  
; -----------------------------  
  
BDOS            equ     0005h  
  
BDOS_CONIN      equ     01h     ; A = char (echoed)  
  
BDOS_CONOUT     equ     02h     ; E = char  
  
BDOS_PRINTSTR   equ     09h     ; DE = '$'-terminated string  
  
CR              equ     0Dh  
  
LF              equ     0Ah  
  
; -----------------------------  
  
; Memory layout  
  
; -----------------------------  
  
STACK_TOP       equ     0F380h  
  
DS_BASE         equ     0F000h          ; data stack base (16-bit cells)  
  
DS_CELLS        equ     64  
  
DS_END          equ     DS_BASE + DS_CELLS*2  
  
RS_BASE         equ     0F100h          ; return stack base (16-bit cells)  
  
RS_CELLS        equ     64  
  
RS_END          equ     RS_BASE + RS_CELLS*2  
  
; ============================================================  
  
; (4) Host callgate (BDOS wrappers)  
  
; ============================================================  
  
bdos_printstr:  
  
               ld      c, BDOS_PRINTSTR  
  
               call    BDOS  
  
               ret  
  
emit_a:  
  
               ; A = char  
  
               ld      e, a  
  
               ld      c, BDOS_CONOUT  
  
               call    BDOS  
  
               ret  
  
key_a:  
  
               ld      c, BDOS_CONIN  
  
               call    BDOS  
  
               ret  
  
print_crlf:  
  
               ld      a, CR  
  
               call    emit_a  
  
               ld      a, LF  
  
               call    emit_a  
  
               ret  
  
; ============================================================  
  
; (2) Stacks: data stack (DSP=IY) and return stack (RSP=IX)  
  
; Convention:  
  
;   - Empty: IY = DS_BASE-2  
  
;   - push HL: IY+=2, [IY]=HL  
  
;   - pop  HL: HL=[IY], IY-=2  
  
; Return stack uses IX similarly.  
  
; ============================================================  
  
ds_init:  
  
               ld      iy, DS_BASE-2  
  
               ret  
  
rs_init:  
  
               ld      ix, RS_BASE-2  
  
               ret  
  
ds_push_hl:  
  
               inc     iy  
  
               inc     iy  
  
               ld      (iy+0), l  
  
               ld      (iy+1), h  
  
               ret  
  
ds_pop_hl:  
  
               ld      l, (iy+0)  
  
               ld      h, (iy+1)  
  
               dec     iy  
  
               dec     iy  
  
               ret  
  
rs_push_hl:  
  
               inc     ix  
  
               inc     ix  
  
               ld      (ix+0), l  
  
               ld      (ix+1), h  
  
               ret  
  
rs_pop_hl:  
  
               ld      l, (ix+0)  
  
               ld      h, (ix+1)  
  
               dec     ix  
  
               dec     ix  
  
               ret  
  
rs_is_empty:  
  
               ; Z=1 if empty  
  
               ld      hl, RS_BASE-2  
  
               or      a  
  
               sbc     hl, ix  
  
               ret  
  
; ============================================================  
  
; (1)(3) Inner Interpreter  
  
;   PC is a pointer to a thread of 16-bit cells.  
  
;   Each cell is an opcode or operand.  
  
;  
  
; Opcodes (16-bit cell values):  
  
;   0  STOP     : halt VM  
  
;   1  LIT      : push next cell  
  
;   2  ADD      : (a b -- a+b)  
  
;   3  EMIT     : (x -- ) output low byte as char  
  
;   4  KEY      : ( -- x) get char  
  
;   5  PRINT1   : (x -- ) print single digit '0'+x  (0..9)  
  
;   6  JMP      : pc = next cell (absolute thread address)  
  
;   7  JMPZ     : if pop()==0 then pc = next cell else skip target  
  
;   8  CALL     : push return pc, pc = next cell  
  
;   9  EXIT     : pc = rpop(); if empty -> STOP  
  
;  
  
; Note:  
  
;   - This is intentionally small and explicit for learning.  
  
;   - It models CF's "inner" + "VM命令" separation.  
  
; ============================================================  
  
OP_STOP         equ     0  
  
OP_LIT          equ     1  
  
OP_ADD          equ     2  
  
OP_EMIT         equ     3  
  
OP_KEY          equ     4  
  
OP_PRINT1       equ     5  
  
OP_JMP          equ     6  
  
OP_JMPZ         equ     7  
  
OP_CALL         equ     8  
  
OP_EXIT         equ     9  
  
; pc in DE (16-bit address)  
  
; fetch cell: HL = (DE), DE += 2  
  
fetch_cell_hl:  
  
               ld      a, (de)  
  
               ld      l, a  
  
               inc     de  
  
               ld      a, (de)  
  
               ld      h, a  
  
               inc     de  
  
               ret  
  
; main VM loop  
  
vm_run:  
  
.vm_next:  
  
               call    fetch_cell_hl          ; HL = opcode  
  
               ld      a, l                   ; opcode in A (low byte enough)  
  
               cp      OP_STOP  
  
               jr      z, .op_stop  
  
               cp      OP_LIT  
  
               jr      z, .op_lit  
  
               cp      OP_ADD  
  
               jr      z, .op_add  
  
               cp      OP_EMIT  
  
               jr      z, .op_emit  
  
               cp      OP_KEY  
  
               jr      z, .op_key  
  
               cp      OP_PRINT1  
  
               jr      z, .op_print1  
  
               cp      OP_JMP  
  
               jr      z, .op_jmp  
  
               cp      OP_JMPZ  
  
               jr      z, .op_jmpz  
  
               cp      OP_CALL  
  
               jr      z, .op_call  
  
               cp      OP_EXIT  
  
               jr      z, .op_exit  
  
               ; unknown opcode => stop (safe)  
  
.op_stop:  
  
               ret  
  
.op_lit:  
  
               ; push next cell literal  
  
               call    fetch_cell_hl  
  
               call    ds_push_hl  
  
               jr      .vm_next  
  
.op_add:  
  
               ; (a b -- a+b)  
  
               call    ds_pop_hl              ; HL=b  
  
               ex      de, hl                 ; DE=b  
  
               call    ds_pop_hl              ; HL=a  
  
               add     hl, de                 ; HL=a+b  
  
               call    ds_push_hl  
  
               jr      .vm_next  
  
.op_emit:  
  
               ; (x -- ) output low byte  
  
               call    ds_pop_hl  
  
               ld      a, l  
  
               call    emit_a  
  
               jr      .vm_next  
  
.op_key:  
  
               ; ( -- x)  
  
               call    key_a                  ; A=char  
  
               ld      l, a  
  
               ld      h, 0  
  
               call    ds_push_hl  
  
               jr      .vm_next  
  
.op_print1:  
  
               ; (x -- ) print '0'+x (0..9)  
  
               call    ds_pop_hl  
  
               ld      a, l  
  
               add     a, '0'  
  
               call    emit_a  
  
               jr      .vm_next  
  
.op_jmp:  
  
               ; pc = next cell (absolute address)  
  
               call    fetch_cell_hl          ; HL=target  
  
               ex      de, hl                 ; DE=target  
  
               jr      .vm_next  
  
.op_jmpz:  
  
               ; if pop()==0 then pc=target else skip target  
  
               call    ds_pop_hl              ; HL=cond  
  
               ld      a, h  
  
               or      l  
  
               jr      z, .jz_taken  
  
               ; not taken: skip target cell  
  
               inc     de  
  
               inc     de  
  
               jr      .vm_next  
  
.jz_taken:  
  
               call    fetch_cell_hl          ; HL=target  
  
               ex      de, hl  
  
               jr      .vm_next  
  
.op_call:  
  
               ; push return pc, jump to target  
  
               ; return pc is current DE after reading target cell, so:  
  
               call    fetch_cell_hl          ; HL=target  
  
               push    hl                     ; save target  
  
               ex      de, hl                 ; HL=current pc (after target)?? careful:  
  
               ; At this moment DE points after target already, so DE is return pc.  
  
               ; Save DE as return pc:  
  
               ex      de, hl                 ; HL = return pc, DE = ??? (was target saved on stack)  
  
               call    rs_push_hl  
  
               pop     hl                     ; HL=target  
  
               ex      de, hl                 ; DE=target  
  
               jr      .vm_next  
  
.op_exit:  
  
               ; if return stack empty => STOP else pc=rpop  
  
               call    rs_is_empty  
  
               jr      z, .op_stop  
  
               call    rs_pop_hl  
  
               ex      de, hl                 ; DE = return pc  
  
               jr      .vm_next  
  
; ============================================================  
  
; Demo thread (runs under VM)  
  
;   Prints: "ANS=" then single digit result of 2 3 + (=5) then CRLF  
  
; ============================================================  
  
start:  
  
               ld      sp, STACK_TOP  
  
               call    ds_init  
  
               call    rs_init  
  
               ; Print banner via BDOS (host side)  
  
               ld      de, str_banner  
  
               call    bdos_printstr  
  
               ; Run VM on demo thread  
  
               ld      de, thread_demo  
  
               call    vm_run  
  
               ; Back to DOS (or loop if you prefer)  
  
               ret  
  
; Thread format: sequence of 16-bit cells (opcode/operand)  
  
thread_demo:  
  
               dw      OP_LIT, 'A'  
  
               dw      OP_EMIT  
  
               dw      OP_LIT, 'N'  
  
               dw      OP_EMIT  
  
               dw      OP_LIT, 'S'  
  
               dw      OP_EMIT  
  
               dw      OP_LIT, '='  
  
               dw      OP_EMIT  
  
               dw      OP_LIT, 2  
  
               dw      OP_LIT, 3  
  
               dw      OP_ADD  
  
               dw      OP_PRINT1  
  
               dw      OP_LIT, CR  
  
               dw      OP_EMIT  
  
               dw      OP_LIT, LF  
  
               dw      OP_EMIT  
  
               dw      OP_STOP  
  
; ------------------------------------------------------------  
  
; Strings ($ terminated for BDOS 9)  
  
; ------------------------------------------------------------  
  
str_banner:      db      "CF-MSX0 kernel test (inner/stack/opcode/callgate)$"    
~~~
---  
  
# **これが「障害は何か？」を見抜くために役立つ理由**  
  
この1本で、MSX0における“処理系を書く難しさ”の核心を、順番に体感できます：  
  
1. NEXT/dispatch を自分で書く必要がある（Forthの卵問題）    
2. スタック規約を固定しないと、全部のprimitiveが崩れる    
3. LIT/BRANCH/EXIT 等のVM命令は PRIMS とは別枠として必須（CFでも別）    
4. BDOS/BIOS呼び出しの橋は必ず必要（WORD化のための土台）  
  
---  
  
# **次のステップ（あなたの“CFをMSX0へ”の障害調査として最優先）**  
  
このカーネルが MSX0 で動いたら、次に「CFへ近づける障害」はだいたい次の3つに絞れます：  
  
* 辞書構造（DE_T相当）をMSXのメモリ上でどう持つか    
* outer（トークン分解、数値解釈、find/execute/compile）をどこまでZ80で持つか    
* * / /mod をソフト実装するか、最初は削るか（あなたのBの懸念）  
  
---  
  
もしよければ、次はこの最小核の上に **CFの compileNumber() と同じ仕様（NUM_BITS 即値圧縮も含む/含まないの2案）**を載せて、  
  
* : foo 123 ; foo が動くところまで    
* まだファイルやOSは無し  
  
…という **「CF移植の最短到達点」**を asm で作れます。  
  
まずはこのカーネルを MSX0 で動かして、ANS=5 が出るか試してみてください。動かなかった場合は、MSX0側の実行環境（MSX-DOSの種類、エミュレータ/実機、sjasmplusの出力ログ）を貼ってくれれば、そこで詰まる“MSX固有の障害”を特定できます。  
  
[(次へ進む　＜現在工事中です＞)](./CF-MSX_10_a.md)      
[(README.mdへ戻る)](../README.md)      
